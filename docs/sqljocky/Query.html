        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Query class / sqljocky Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="sqljocky" data-type="Query">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../sqljocky.html">sqljocky</a> &rsaquo; <a href="../sqljocky/Query.html">Query</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Query</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>Query is created by <code>ConnectionPool.prepare(sql)</code> and <code>Transaction.prepare(sql)</code>. It holds
a prepared query.</p>
<p>In MySQL, a query must be prepared on a specific connection. If you execute this
query and a connection is used from the pool which doesn't yet have the prepared query
in its cache, it will first prepare the query on that connection before executing it.</p>
<pre class="source">
class Query extends Object with _ConnectionHelpers {
 final ConnectionPool _pool;
 final _Connection _cnx;
 final String sql;
 final Logger _log;
 final _inTransaction;
 bool _executed = false;
 
 Query._internal(this._pool, this.sql) :
     _cnx = null,
     _inTransaction = false,
     _log = new Logger("Query");

 Query._forTransaction(this._pool, _Connection cnx, this.sql) :
     _cnx = cnx,
     _inTransaction = true,
     _log = new Logger("Query");
 
 Future&lt;_Connection&gt; _getConnection() {
   if (_cnx != null) {
     var c = new Completer&lt;_Connection&gt;();
     c.complete(_cnx);
     return c.future;
   }
   return _pool._getConnection();
 }

 Future&lt;_PreparedQuery&gt; _prepare(bool retainConnection) {
   _log.fine("Getting prepared query for: $sql");
   
   return _getConnection()
     .then((cnx) {
       cnx.autoRelease = !retainConnection;
       var c = new Completer&lt;_PreparedQuery&gt;();
       _log.fine("Got cnx#${cnx.number}");
       if (_useCachedQuery(cnx, c)) {
         if (!retainConnection) {
           // didn't actually use the connection, so the auto-release
           // mechanism will never get fired, so we'd better give up
           // on the connection now
           cnx.release();
         }
       } else {
         _prepareAndCacheQuery(cnx, c, retainConnection);
       }
       return c.future;
     });
 }
 
 /**
  * Returns true if there was already a cached query which has been used.
  */
 bool _useCachedQuery(_Connection cnx, Completer c) {
   var preparedQuery = cnx.getPreparedQueryFromCache(sql);
   if (preparedQuery == null) {
     return false;
   }

   _log.fine("Got prepared query from cache in cnx#${cnx.number} for: $sql");
   c.complete(preparedQuery);
   return true;
 }
 
 void _prepareAndCacheQuery(_Connection cnx, Completer c, retainConnection) {
   _log.fine("Preparing new query in cnx#${cnx.number} for: $sql");
   var handler = new _PrepareHandler(sql);
   cnx.use();
   cnx.autoRelease = !retainConnection;
   cnx.processHandler(handler)
     .then((preparedQuery) {
       _log.fine("Prepared new query in cnx#${cnx.number} for: $sql");
       preparedQuery.cnx = cnx;
       cnx.putPreparedQueryInCache(sql, preparedQuery);
       c.complete(preparedQuery);
     })
     .catchError((e) {
       _releaseReuseCompleteError(cnx, c, e);
     });
 }

 /// Closes this query and removes it from all connections in the pool.
 void close() {
   _pool._closeQuery(this, _inTransaction);
 }
 
 /**
  * Executes the query, returning a future [Results] object.
  */
 Future&lt;Results&gt; execute([List values]) {
   _log.fine("Prepare...");
   return _prepare(true)
     .then((preparedQuery) {
       _log.fine("Prepared, now to execute");
       return _execute(preparedQuery, values == null ? [] : values)
         .then((Results results) {
           _log.fine("Got prepared query results on #${preparedQuery.cnx.number} for: ${sql}");
           return results;
         });
     });
 }
 
 Future&lt;Results&gt; _execute(_PreparedQuery preparedQuery, List values,
     {bool retainConnection: false}) {
   _log.finest("About to execute");
   var c = new Completer&lt;Results&gt;();
   var handler = new _ExecuteQueryHandler(preparedQuery, _executed, values);
   preparedQuery.cnx.autoRelease = !retainConnection;
   preparedQuery.cnx.processHandler(handler)
     .then((results) {
       _log.finest("Prepared query got results");
       c.complete(results);
     })
     .catchError((e) {
       _releaseReuseCompleteError(preparedQuery.cnx, c, e);
     });
   return c.future;
 }

 /**
  * Executes the query once for each set of [parameters], and returns a future list
  * of results, one for each set of parameters, that completes when the query has been executed.
  *
  * The [Results] in the list contain their rows in the [Results.rows] field, rather than in the
  * [Results.stream] field.
  */
 Future&lt;List&lt;Results&gt;&gt; executeMulti(List&lt;List&gt; parameters) {
   return _prepare(true)
     .then((preparedQuery) {
       var c = new Completer&lt;List&lt;Results&gt;&gt;();
       _log.fine("Prepared query for multi execution. Number of values: ${parameters.length}");
       var resultList = new List&lt;Results&gt;();
       
       executeQuery(int i) {
         _log.fine("Executing query, loop $i");
         _execute(preparedQuery, parameters[i], retainConnection: true)
           .then((Results results) {
             _log.fine("Got results, loop $i");
             resultList.add(results);
             if (i &lt; parameters.length - 1) {
               executeQuery(i + 1);
             } else {
               preparedQuery.cnx.release();
               c.complete(resultList);
             }
           })
           .catchError((e) {
             _releaseReuseCompleteError(preparedQuery.cnx, c, e);
           });
       }
       
       executeQuery(0);
       return c.future;
     });
 }
 
 _removeConnection(_Connection cnx) {
   if (!_inTransaction) {
     _pool._removeConnection(cnx);
   }
 }
//  dynamic longData(int index, data);
//  dynamic reset();
//  dynamic fetch(int rows);
}
</pre>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="sql">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>sql</strong> <a class="anchor-link"
            href="#sql"
            title="Permalink to Query.sql">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final String sql
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="close">
<button class="show-code">Code</button>
void <strong>close</strong>() <a class="anchor-link" href="#close"
              title="Permalink to Query.close">#</a></h4>
<div class="doc">
<p>Closes this query and removes it from all connections in the pool.</p>
<pre class="source">
void close() {
 _pool._closeQuery(this, _inTransaction);
}
</pre>
</div>
</div>
<div class="method"><h4 id="execute">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../results/Results.html">Results</a>&gt; <strong>execute</strong>([<a href="http://api.dartlang.org/dart_core/List.html">List</a> values]) <a class="anchor-link" href="#execute"
              title="Permalink to Query.execute">#</a></h4>
<div class="doc">
<p>Executes the query, returning a future <a class="crossref" href="../results/Results.html">Results</a> object.</p>
<pre class="source">
Future&lt;Results&gt; execute([List values]) {
 _log.fine("Prepare...");
 return _prepare(true)
   .then((preparedQuery) {
     _log.fine("Prepared, now to execute");
     return _execute(preparedQuery, values == null ? [] : values)
       .then((Results results) {
         _log.fine("Got prepared query results on #${preparedQuery.cnx.number} for: ${sql}");
         return results;
       });
   });
}
</pre>
</div>
</div>
<div class="method"><h4 id="executeMulti">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../results/Results.html">Results</a>&gt;&gt; <strong>executeMulti</strong>(<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_core/List.html">List</a>&gt; parameters) <a class="anchor-link" href="#executeMulti"
              title="Permalink to Query.executeMulti">#</a></h4>
<div class="doc">
<p>Executes the query once for each set of 
<span class="param">parameters</span>, and returns a future list
of results, one for each set of parameters, that completes when the query has been executed.</p>
<p>The <a class="crossref" href="../results/Results.html">Results</a> in the list contain their rows in the <code>Results.rows</code> field, rather than in the
<code>Results.stream</code> field.</p>
<pre class="source">
Future&lt;List&lt;Results&gt;&gt; executeMulti(List&lt;List&gt; parameters) {
 return _prepare(true)
   .then((preparedQuery) {
     var c = new Completer&lt;List&lt;Results&gt;&gt;();
     _log.fine("Prepared query for multi execution. Number of values: ${parameters.length}");
     var resultList = new List&lt;Results&gt;();
     
     executeQuery(int i) {
       _log.fine("Executing query, loop $i");
       _execute(preparedQuery, parameters[i], retainConnection: true)
         .then((Results results) {
           _log.fine("Got results, loop $i");
           resultList.add(results);
           if (i &lt; parameters.length - 1) {
             executeQuery(i + 1);
           } else {
             preparedQuery.cnx.release();
             c.complete(resultList);
           }
         })
         .catchError((e) {
           _releaseReuseCompleteError(preparedQuery.cnx, c, e);
         });
     }
     
     executeQuery(0);
     return c.future;
   });
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-11-25 14:57:07.426</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
